<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">assignment7</a> &gt; <a href="index.source.html" class="el_package">assignment7</a> &gt; <span class="el_source">AbstractValidator.java</span></div><h1>AbstractValidator.java</h1><pre class="source lang-java linenums">package assignment7;

import java.util.HashMap;

/**
 * Abstract Validator Class
 */
public abstract class AbstractValidator&lt;T&gt; implements IValidator&lt;T&gt; {

  /**
   * The Abstract Validator Class implements iValidator.
   */
<span class="fc" id="L13">  public AbstractValidator() {</span>
<span class="fc" id="L14">  }</span>

  /**
   * Checks if the user input is valid for a the field.
   * @param input the user input
   * @return True if the input is valid for the field, false otherwise.
   */
  @Override
  public boolean isValid(T input) {
<span class="nc" id="L23">    return false;</span>
  }

  /**
   * Returns a hash code value for the object. This method is supported for the benefit of hash
   * tables such as those provided by {@link HashMap}.
   * &lt;p&gt;
   * The general contract of {@code hashCode} is:
   * &lt;ul&gt;
   * &lt;li&gt;Whenever it is invoked on the same object more than once during
   *     an execution of a Java application, the {@code hashCode} method
   *     must consistently return the same integer, provided no information
   *     used in {@code equals} comparisons on the object is modified.
   *     This integer need not remain consistent from one execution of an
   *     application to another execution of the same application.
   * &lt;li&gt;If two objects are equal according to the {@code equals(Object)}
   *     method, then calling the {@code hashCode} method on each of
   *     the two objects must produce the same integer result.
   * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
   *     according to the {@link Object#equals(Object)}
   *     method, then calling the {@code hashCode} method on each of the
   *     two objects must produce distinct integer results.  However, the
   *     programmer should be aware that producing distinct integer results
   *     for unequal objects may improve the performance of hash tables.
   * &lt;/ul&gt;
   * &lt;p&gt;
   * As much as is reasonably practical, the hashCode method defined
   * by class {@code Object} does return distinct integers for
   * distinct objects. (The hashCode may or may not be implemented
   * as some function of an object's memory address at some point
   * in time.)
   *
   * @return a hash code value for this object.
   * @see Object#equals(Object)
   * @see System#identityHashCode
   */
  @Override
  public int hashCode() {
<span class="nc" id="L61">    int hash = 17;</span>
<span class="nc" id="L62">    return hash;</span>
  }

  /**
   * Indicates whether some other object is &quot;equal to&quot; this one.
   * &lt;p&gt;
   * The {@code equals} method implements an equivalence relation on non-null object references:
   * &lt;ul&gt;
   * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value
   *     {@code x}, {@code x.equals(x)} should return
   *     {@code true}.
   * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values
   *     {@code x} and {@code y}, {@code x.equals(y)}
   *     should return {@code true} if and only if
   *     {@code y.equals(x)} returns {@code true}.
   * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values
   *     {@code x}, {@code y}, and {@code z}, if
   *     {@code x.equals(y)} returns {@code true} and
   *     {@code y.equals(z)} returns {@code true}, then
   *     {@code x.equals(z)} should return {@code true}.
   * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values
   *     {@code x} and {@code y}, multiple invocations of
   *     {@code x.equals(y)} consistently return {@code true}
   *     or consistently return {@code false}, provided no
   *     information used in {@code equals} comparisons on the
   *     objects is modified.
   * &lt;li&gt;For any non-null reference value {@code x},
   *     {@code x.equals(null)} should return {@code false}.
   * &lt;/ul&gt;
   * &lt;p&gt;
   * The {@code equals} method for class {@code Object} implements
   * the most discriminating possible equivalence relation on objects;
   * that is, for any non-null reference values {@code x} and
   * {@code y}, this method returns {@code true} if and only
   * if {@code x} and {@code y} refer to the same object
   * ({@code x == y} has the value {@code true}).
   * &lt;p&gt;
   * Note that it is generally necessary to override the {@code hashCode}
   * method whenever this method is overridden, so as to maintain the
   * general contract for the {@code hashCode} method, which states
   * that equal objects must have equal hash codes.
   *
   * @param obj the reference object with which to compare.
   * @return {@code true} if this object is the same as the obj argument; {@code false} otherwise.
   * @see #hashCode()
   * @see HashMap
   */
  @Override
  public boolean equals(Object obj) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (!super.equals(obj)) {return false;}</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">    if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L113">      return false;</span>
    }
<span class="nc" id="L115">    return true;</span>
  }

  /**
   * Returns a string representation of the object. In general, the {@code toString} method returns
   * a string that &quot;textually represents&quot; this object. The result should be a concise but
   * informative representation that is easy for a person to read. It is recommended that all
   * subclasses override this method.
   * &lt;p&gt;
   * The {@code toString} method for class {@code Object} returns a string consisting of the name of
   * the class of which the object is an instance, the at-sign character `{@code @}', and the
   * unsigned hexadecimal representation of the hash code of the object. In other words, this method
   * returns a string equal to the value of:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * getClass().getName() + '@' + Integer.toHexString(hashCode())
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @return a string representation of the object.
   */
  @Override
  public String toString() {
<span class="fc" id="L137">    return &quot;This is a Validator Object of Type: &quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>